{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the context the term “migration” means dealing with changes to the database"},{"type":"text","text":" "},{"type":"text","text":"schema."},{"type":"text","text":" "},{"type":"text","text":"For example v1 of an app might have created a database table that looks like"},{"type":"text","text":" "},{"type":"text","text":"this:"}]},{"type":"codeListing","syntax":"sql","code":["CREATE TABLE contact (","    id   INT  NOT NULL PRIMARY KEY,","    name TEXT NOT NULL",");"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And v2 of the app added an "},{"type":"codeVoice","code":"age"},{"type":"text","text":" field:"}]},{"type":"codeListing","syntax":"sql","code":["ALTER TABLE contact ADD COLUMN age INT NULL;"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Resulting in a new schema:"}]},{"type":"codeListing","syntax":"sql","code":["CREATE TABLE contact (","    id   INT  NOT NULL PRIMARY KEY,","    name TEXT NOT NULL,","    age  INT  NULL",");"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This only is relevant for databases that are not packaged as resources,"},{"type":"text","text":" "},{"type":"text","text":"e.g. caches or document databases. Resource database always automatically"},{"type":"text","text":" "},{"type":"text","text":"match up with the generated code."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the new v2 version of the app is released, existing users might still"},{"type":"text","text":" "},{"type":"text","text":"have a v1 database."},{"type":"text","text":" "},{"type":"text","text":"“Migrations” is the process to deal with that."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"How migrations should be handled depends a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lot"}]},{"type":"text","text":" on the actual use case."},{"type":"text","text":" "},{"type":"text","text":"There are various approaches on dealing with them."},{"type":"text","text":" "},{"type":"text","text":"Lighter (like SQLite) itself doesn’t have migration functionality builtin,"},{"type":"text","text":" "},{"type":"text","text":"but it is easy to build such on top."}]},{"anchor":"Detecting-Old-Database-Versions","level":3,"type":"heading","text":"Detecting Old Database Versions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One (and the recommended) SQLite way to communicate schema changes is the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.sqlite.org\/pragma.html#pragma_user_version"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This pragma is simply an persistent integer value that the user can set to"},{"type":"text","text":" "},{"type":"text","text":"anything."},{"type":"text","text":" "},{"type":"text","text":"But its most common use is as a schema change indicator."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example the above SQL should be done like this:"}]},{"type":"codeListing","syntax":"sql","code":["CREATE TABLE contact (","    id   INT  NOT NULL PRIMARY KEY,","    name TEXT NOT NULL",");","PRAGMA user_version = 1; -- tag the schema version"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then if the schema is modified, that version should be bumped:"}]},{"type":"codeListing","syntax":"sql","code":["ALTER TABLE contact ADD COLUMN age INT NULL;","PRAGMA user_version = 2; -- tag the new schema version"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now when the application starts up (or a document is opened), it can retrieve"},{"type":"text","text":" "},{"type":"text","text":"this version:"}]},{"type":"codeListing","syntax":"swift","code":["let fileVersion = try database.get(pragma: \"user_version\", as: Int.self)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which will return "},{"type":"codeVoice","code":"1"},{"type":"text","text":" for old database files and "},{"type":"codeVoice","code":"2"},{"type":"text","text":" for v2 database files."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The version the database had when generating the Swift code for it"},{"type":"text","text":" "},{"type":"text","text":"is stored in the "},{"type":"codeVoice","code":"userVersion"},{"type":"text","text":" property of the database structure."},{"type":"text","text":" "},{"type":"text","text":"To detect whether something has changed with respect to the running code:"}]},{"type":"codeListing","syntax":"swift","code":["let fileVersion = try database.get(pragma: \"user_version\", as: Int.self)","if fileVersion != BodiesDB.userVersion {","    print(\"The database version has changed!\")","}"]},{"style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"What a version change "},{"type":"strong","inlineContent":[{"type":"text","text":"means"}]},{"type":"text","text":" is entirely application specific,"},{"type":"text","text":" "},{"type":"text","text":"and its requirements for downwards and upwards compatibility."},{"type":"text","text":" "},{"type":"text","text":"It is tempting to say that each version bump needs to result in a migration,"},{"type":"text","text":" "},{"type":"text","text":"but that isn’t necessarily true."},{"type":"text","text":" "},{"type":"text","text":"If the change was purely additive (e.g. another table got added),"},{"type":"text","text":" "},{"type":"text","text":"an application might still work with the “older” database file but reduce"},{"type":"text","text":" "},{"type":"text","text":"the available functionality (maybe letting the user decide to “upgrade”)."}]}],"type":"aside","name":"Important"},{"anchor":"Simple-Solution-for-Caches-Drop--Recreate","level":3,"type":"heading","text":"Simple Solution for Caches: Drop & Recreate"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the database is really just used as a network cache for offline first,"},{"type":"text","text":" "},{"type":"text","text":"and not so large that a cache rebuild would be expensive,"},{"type":"text","text":" "},{"type":"text","text":"just dropping the cache database can be quick option."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A good place to do this is the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" of an application for app-wide databases"},{"type":"text","text":" "},{"type":"text","text":"e.g. from the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Lighter-swift\/Examples\/tree\/develop\/Sources\/Bodies\/"},{"type":"text","text":" "},{"type":"text","text":"example:"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct BodiesApp: App {","    ","    let database = try! BodiesDB.bootstrap(into: .cachesDirectory)","    ","    init() {","        let schemaVersion =","            try! database.get(pragma: \"user_version\", as: Int.self)","        if schemaVersion != BodiesDB.userVersion {","            print(\"Dumping cache, the version is outdated.\")","            _ = try! BodiesDB.bootstrap(into: .cachesDirectory, overwrite: true)","        }","    }","...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This makes sure the database is the latest prior being used by any"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI Views."}]},{"anchor":"Simple-Solution-for-Caches-Version-the-Filename","level":3,"type":"heading","text":"Simple Solution for Caches: Version the Filename"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If different applications or extensions share the same cache, it can also"},{"type":"text","text":" "},{"type":"text","text":"be useful to put it into a version filename:"}]},{"type":"codeListing","syntax":"swift","code":["let filename = \"BodiesDB-\\(BodiesDB.userVersion).sqlite3\"","let database = ","    try BodiesDB.bootstrap(into: .cachesDirectory, filename: filename)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way different versions can co-exist."}]},{"anchor":"SQL-Resource-File-Based-Migrations","level":3,"type":"heading","text":"SQL Resource File Based Migrations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When generating the Swift code, Enlighter and companions do not only look at"},{"type":"text","text":" "},{"type":"text","text":"individual files, e.g. "},{"type":"codeVoice","code":"BodiesDB.sql"},{"type":"text","text":". They actually group files with the same"},{"type":"text","text":" "},{"type":"text","text":"name together, e.g. "},{"type":"codeVoice","code":"BodiesDB.sql"},{"type":"text","text":" and "},{"type":"codeVoice","code":"BodiesDB-create-indices.sql"},{"type":"text","text":" would both"},{"type":"text","text":" "},{"type":"text","text":"form a group that results in the "},{"type":"codeVoice","code":"BodiesDB"},{"type":"text","text":" database."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since the group is applied after being sorted, this can be used to implement"},{"type":"text","text":" "},{"type":"text","text":"a really easy migration mechanism. Simply put each migration into a simple"},{"type":"text","text":" "},{"type":"text","text":"file with the version being part of the file name:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"File "},{"type":"codeVoice","code":"ContactsDB-001.sql"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"sql","code":["CREATE TABLE contact (","    id   INT  NOT NULL PRIMARY KEY,","    name TEXT NOT NULL",");","PRAGMA user_version = 1; -- tag the schema version"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"File "},{"type":"codeVoice","code":"ContactsDB-002.sql"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"sql","code":["ALTER TABLE contact ADD COLUMN age INT NULL;","PRAGMA user_version = 2; -- tag the new schema version"]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Enlighter will combine both files into the "},{"type":"codeVoice","code":"ContactsDB"},{"type":"text","text":" structure. If the files"},{"type":"text","text":" "},{"type":"text","text":"are also embedded as resource files into the application bundle, they can be"},{"type":"text","text":" "},{"type":"text","text":"executed at runtime (pseudo code):"}]},{"type":"codeListing","syntax":"swift","code":["let fileVersion = try database.get(pragma: \"user_version\", as: Int.self)","guard fileVersion < BodiesDB.userVersion else { return }","","for i in (fileVersion + 1)...BodiesDB.userVersion {","    let filename = \"ContactsDB-\\(leftpad(i, 3)).sql\" \/\/ ;-)","    let url = Bundle.main.urlForResource(filename, ofType: \"sql\")","    let sql = try String(contentsOf: url)","    try database.execute(sql)","}"]},{"anchor":"During-Development","level":3,"type":"heading","text":"During Development"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the SQL for a database is still being developed on and modified often,"},{"type":"text","text":" "},{"type":"text","text":"the developer may want to start out with a clean database with the latest schema"},{"type":"text","text":" "},{"type":"text","text":"on startup."},{"type":"text","text":" "},{"type":"text","text":"This can be done using the "},{"type":"codeVoice","code":"overwrite"},{"type":"text","text":" parameter in the "},{"type":"codeVoice","code":"bootstrap"},{"type":"text","text":" functions,"},{"type":"text","text":" "},{"type":"text","text":"e.g. from the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"Solar Bodies"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/Lighter-swift\/Examples\/tree\/develop\/Sources\/Bodies\/","overridingTitle":"Solar Bodies"},{"type":"text","text":" "},{"type":"text","text":"example:"}]},{"type":"codeListing","syntax":"swift","code":["@main","struct BodiesApp: App {","  ","    #if DEBUG","    let database = try! BodiesDB.bootstrap(overwrite: true)","    #else","    let database = try! BodiesDB.bootstrap()","    #endif","    ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using the "},{"type":"codeVoice","code":"#if DEBUG"},{"type":"text","text":" is recommended, so that an "},{"type":"codeVoice","code":"overwrite"},{"type":"text","text":" doesn’t"},{"type":"text","text":" "},{"type":"text","text":"accidentially leak into a production deployment."}]},{"anchor":"Keeping-Multiple-Code-Versions-in-the-App","level":3,"type":"heading","text":"Keeping Multiple Code Versions in the App"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is also possible to keep generated Swift code for multiple version in a"},{"type":"text","text":" "},{"type":"text","text":"single app."},{"type":"text","text":" "},{"type":"text","text":"Simply keep both versions as separate “databases”. E.g. "},{"type":"codeVoice","code":"OldContactsDB.sql"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"codeVoice","code":"NewContactsDB.sql"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then use the "},{"type":"codeVoice","code":"embedRecordTypesInDatabaseType"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Configuration"},{"type":"text","text":", and only"},{"type":"text","text":" "},{"type":"text","text":"set it to "},{"type":"codeVoice","code":"false"},{"type":"text","text":" for the latest database"},{"type":"text","text":" "},{"type":"text","text":"(or set it to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" for all versions)."},{"type":"text","text":" "},{"type":"text","text":"It’ll end up with something like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct OldContactsDB: SQLDatabase {","","    struct Contact: SQLTableRecord {} \/\/ the older version","}","struct NewContactsDB: SQLDatabase {","}","struct Contact: SQLTableRecord {} \/\/ the latest version"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way different versions of database files can be used with generated code,"},{"type":"text","text":" "},{"type":"text","text":"only the database struct has to be toggled."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The same is possible w\/ the SQLite3 API when the type-attached function"},{"type":"text","text":" "},{"type":"text","text":"generators are used."}]},{"anchor":"SQLite-Schema-Modification-Specifics","level":3,"type":"heading","text":"SQLite Schema Modification Specifics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Schema migrations sometimes require custom work due to SQLite limitations,"},{"type":"text","text":" "},{"type":"text","text":"this is a good document on the specifics:"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.sqlite.org\/lang_altertable.html#making_other_kinds_of_table_schema_changes"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/lighter\/migrations"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Lighter\/documentation\/Lighter\/Migrations","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Detecting schema changes and performing schema upgrades."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Migrations","role":"article","modules":[{"name":"Lighter.swift for SQLite3"}]},"hierarchy":{"paths":[["doc:\/\/Lighter\/documentation\/Lighter"]]},"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/Lighter\/documentation\/Lighter\/Configuration","doc:\/\/Lighter\/documentation\/Lighter\/Linux","doc:\/\/Lighter\/documentation\/Lighter\/Manual","doc:\/\/Lighter\/documentation\/Lighter\/SQLiteAPI","doc:\/\/Lighter\/documentation\/Lighter\/Mapping","doc:\/\/Lighter\/documentation\/Lighter\/Performance"],"generated":true}],"references":{"doc://Lighter/documentation/Lighter":{"role":"collection","title":"Lighter.swift for SQLite3","abstract":[{"type":"text","text":"Type-safe down to the schema. Very, "},{"type":"strong","inlineContent":[{"type":"text","text":"very"}]},{"type":"text","text":", fast. Dependency free."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter","kind":"symbol","type":"topic","url":"\/documentation\/lighter"},"doc://Lighter/documentation/Lighter/Linux":{"role":"article","title":"Linux","abstract":[{"type":"text","text":"Using Lighter on Linux."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Linux","kind":"article","type":"topic","url":"\/documentation\/lighter\/linux"},"doc://Lighter/documentation/Lighter/Mapping":{"role":"collectionGroup","title":"Mapping","abstract":[{"type":"text","text":"Mapping Data retrieved from the Database."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Mapping","kind":"article","type":"topic","url":"\/documentation\/lighter\/mapping"},"doc://Lighter/documentation/Lighter/Performance":{"role":"article","title":"Performance","abstract":[{"type":"text","text":"A quick look at Lighter performance."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Performance","kind":"article","type":"topic","url":"\/documentation\/lighter\/performance"},"doc://Lighter/documentation/Lighter/SQLiteAPI":{"role":"article","title":"Dependency-Free API","abstract":[{"type":"text","text":"Using the dependency-free SQLite API."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/SQLiteAPI","kind":"article","type":"topic","url":"\/documentation\/lighter\/sqliteapi"},"https://github.com/Lighter-swift/Examples/tree/develop/Sources/Bodies/":{"title":"Solar Bodies","titleInlineContent":[{"type":"text","text":"Solar Bodies"}],"type":"link","identifier":"https:\/\/github.com\/Lighter-swift\/Examples\/tree\/develop\/Sources\/Bodies\/","url":"https:\/\/github.com\/Lighter-swift\/Examples\/tree\/develop\/Sources\/Bodies\/"},"doc://Lighter/documentation/Lighter/Manual":{"role":"article","title":"Manual Generation","abstract":[{"type":"text","text":"How to generate Lighter content by hand."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Manual","kind":"article","type":"topic","url":"\/documentation\/lighter\/manual"},"doc://Lighter/documentation/Lighter/Configuration":{"role":"article","title":"Configuration","abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Lighter.json"},{"type":"text","text":" configuration file."}],"identifier":"doc:\/\/Lighter\/documentation\/Lighter\/Configuration","kind":"article","type":"topic","url":"\/documentation\/lighter\/configuration"},"https://www.sqlite.org/lang_altertable.html#making_other_kinds_of_table_schema_changes":{"title":"SQLite ALTER TABLE","titleInlineContent":[{"type":"text","text":"SQLite ALTER TABLE"}],"type":"link","identifier":"https:\/\/www.sqlite.org\/lang_altertable.html#making_other_kinds_of_table_schema_changes","url":"https:\/\/www.sqlite.org\/lang_altertable.html#making_other_kinds_of_table_schema_changes"},"https://www.sqlite.org/pragma.html#pragma_user_version":{"title":"PRAGMA user_version","titleInlineContent":[{"type":"codeVoice","code":"PRAGMA user_version"}],"type":"link","identifier":"https:\/\/www.sqlite.org\/pragma.html#pragma_user_version","url":"https:\/\/www.sqlite.org\/pragma.html#pragma_user_version"}}}